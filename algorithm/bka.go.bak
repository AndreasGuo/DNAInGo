package algorithm

import (
	"math"
	"math/rand"
)

type BKA struct {
	Pop          Population
	MaxIteration int
	p            float64
	r            float64
}

func (B *BKA) Initialize(pop Population, inds ...Individual) {
	pop.Init()
	if inds != nil && len(inds) > 0 {
		pop.Append(inds)
	}
	B.Pop = pop
	B.p = 0.9
	B.r = rand.Float64()
}

func (B *BKA) Iteration() Individual {
	fits := B.Pop.Fit()
	ZMin := B.Pop.ZMin()
	selectedIndex, intercept := NDKPSort(fits, ZMin)
	gbest := B.Pop.At(selectedIndex).Variance()

	for it := range B.MaxIteration {
		for i := range B.Pop.Size() {
			if i == selectedIndex {
				// This process could not add constraint to variance
				// It generates offspring one by one, not whold population.
				// Although it can be fixed after each evolution,
				// this increases coupling of algorithm and application
				continue
			}
			n := 0.05 * math.Exp(-2*math.Pow(float64(it+1)/float64(B.MaxIteration), 2))

			/* Attacking  */
			newIndividual := B.Pop.At(i)
			xNew := newIndividual.Variance()
			if B.p < B.r {
				//XPos(i,:)+n.*(1+sin(r))*XPos(i,:);
				for j := range B.Pop.VarianceDim() {
					xNew[j] = xNew[j] + n*(1+math.Sin(B.r))*xNew[j]
				}
			} else {
				// XPosNew(i,:)= XPos(i,:).*(n*(2*rand(1,dim)-1)+1);
				for j := range B.Pop.VarianceDim() {
					xNew[j] = xNew[j] * (n*(2*rand.NormFloat64()-1) + 1)
				}
			}
			// Boundary
			for j := range B.Pop.VarianceDim() {
				xNew[j] = max(min(B.Pop.UB(), xNew[j]), B.Pop.LB())
			}

			/* Select Optimal Fitness */
			invNew := B.Pop.At(i).Clone()
			invNew.UpdatePosition(xNew)
			invNew.PostWork()
			// 我觉得不行，这个算法在过程中计算了两次适应度值，而且是一个一个的
			// 那么设计的routine就完全变成了单线程。
			oldDistance := selectOptimal(intercept, B.Pop.At(i).Variance(), ZMin)
			newDistance := selectOptimal(intercept, xNew, ZMin)
			if oldDistance < newDistance {
				B.Pop.UpdatePosition(i, xNew)
			}
			currentDistance := min(oldDistance, newDistance)

			/* Migration */
			v := make([]float64, B.Pop.VarianceDim())
			m := 2.0 * math.Sin(B.r+math.Pi/float64(2))
			s := rand.Intn(B.Pop.Size())
			// ori_value = rand(1,dim);
			//        cauchy_value = tan((ori_value-0.5)*pi);
			oriValue := make([]float64, B.Pop.VarianceDim())
			cauchyValue := make([]float64, B.Pop.VarianceDim())
			for j := range B.Pop.VarianceDim() {
				oriValue[j] = rand.Float64()
				cauchyValue[j] = math.Tan((oriValue[j] - 0.5) * math.Pi)
			}
			copy(v, B.Pop.At(s).Variance())
			for j := range v {
				v[j] -= ZMin[j]
				v[j] = max(v[j], 0)
			}
			dstDistance := distanceToPlane(intercept, v)
			if dstDistance < currentDistance {
				// XPosNew(i,:)=XPos(i,:)+cauchy_value(:,dim).* (XPos(i,:)-XLeader_Pos);
				copy(v, B.Pop.At(i).Variance())
				for j := range xNew {
					// 这里有很大问题
					// 原代码中只取了cauchy_value的最后一个值
					// 回头看下论文原文
					xNew[j] = v[j] + cauchyValue[j]*(v[j]-gbest[j])
				}
			} else {
				// XPosNew(i,:)=XPos(i,:)+cauchy_value(:,dim).* (XLeader_Pos-m.*XPos(i,:));
				copy(v, B.Pop.At(i).Variance())
				for j := range xNew {
					// 这里有很大问题
					// 原代码中只取了cauchy_value的最后一个值
					// 回头看下论文原文
					xNew[j] = v[j] + cauchyValue[j]*(gbest[j]-m*v[j])
				}
			}
			// Boundary
			for j := range B.Pop.VarianceDim() {
				xNew[j] = max(min(B.Pop.UB(), xNew[j]), B.Pop.LB())
			}

			/* Select Optimal */
			oldDistance = selectOptimal(intercept, B.Pop.At(i).Variance(), ZMin)
			newDistance = selectOptimal(intercept, xNew, ZMin)
			if oldDistance < newDistance {
				B.Pop.UpdatePosition(i, xNew)
			}
		}

		// update intercept,ZMin and best Individual
		B.Pop.PostWork()
		fits := B.Pop.Fit()
		ZMin := B.Pop.ZMin()
		selectedIndex, intercept = NDKPSort(fits, ZMin)
		gbest = B.Pop.At(selectedIndex).Variance()
	}
	return B.Pop.At(selectedIndex)
}

func selectOptimal(intercept, variance, ZMin []float64) float64 {
	v := make([]float64, len(variance))
	copy(v, variance)
	for j := range v {
		v[j] -= ZMin[j]
		v[j] = max(v[j], 0)
	}
	return distanceToPlane(intercept, v)
}
